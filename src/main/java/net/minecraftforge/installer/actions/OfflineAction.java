/*
 * Copyright (c) Forge Development LLC
 * SPDX-License-Identifier: LGPL-2.1-only
 */
package net.minecraftforge.installer.actions;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;

import net.minecraftforge.installer.SimpleInstaller;
import net.minecraftforge.installer.json.Artifact;
import net.minecraftforge.installer.json.InstallV1;
import net.minecraftforge.installer.json.Util;
import net.minecraftforge.installer.json.Version.Library;
import net.minecraftforge.installer.json.Version.LibraryDownload;

public class OfflineAction extends Action {
    private final File base = findInstallerBase();
    private final PostProcessors processorsServer;
    private int added = 0;

    protected OfflineAction(InstallV1 profile, ProgressCallback monitor) {
        super(profile, monitor, true);
        this.processorsServer = new PostProcessors(profile, false, monitor);
    }

    @Override
    public boolean run(File target, File installer) throws ActionCanceledException {
        monitor.message("Building offline installer");
        monitor.message("Found Base: " + base);
        target = cleanTarget(target);
        monitor.message("Output: " + target);
        File libDir = new File(target.getParentFile(), "libraries");

        List<File> extraRepos = new ArrayList<>();
        for (File dir : new File[] {
            new File(SimpleInstaller.getMCDir(), "libraries"),
            new File("libraries")
        }) {
            if (dir.exists() && !extraRepos.contains(dir))
                extraRepos.add(dir);
        }

        // Download Libraries
        if (!downloadLibraries(libDir, extraRepos))
            return false;
        checkCancel();

        try (ZipInputStream zin = new ZipInputStream(new FileInputStream(base));
            ZipOutputStream zout = new ZipOutputStream(new FileOutputStream(target))) {

            Set<String> seen = new HashSet<>();
            monitor.message("Copying Base Installer Archive");
            for (ZipEntry entry; (entry = zin.getNextEntry()) != null; ) {
                zout.putNextEntry(getNewEntry(entry.getName()));
                copy(zin, zout);
                if (entry.getName().startsWith("maven/") && !entry.isDirectory())
                    seen.add(entry.getName().substring(6));
            }

            for (Library lib : getLibraries()) {
                Artifact artifact = lib.getName();
                if (!seen.add(artifact.getPath()))
                    continue;

                File local = artifact.getLocalPath(libDir);

                LibraryDownload download = lib.getDownloads() == null ? null :  lib.getDownloads().getArtifact();
                if (download == null) {
                    download = new LibraryDownload();
                    download.setPath(artifact.getPath());
                }

                if (!local.exists()) {
                    if (download.getUrl() == null || download.getUrl().isEmpty()) {
                        monitor.message("Skipping " + artifact.getDescriptor() + " as it's missing its URL, this is probably generated by the installer");
                        continue;
                    } else {
                        error("Library: " + artifact.getDescriptor() + " does not exist, but it should of been downloaded..");
                        monitor.message("Local Path: " + local.getAbsolutePath());
                        return false;
                    }
                }

                monitor.message("Adding: maven/" + artifact.getPath());
                try (FileInputStream fin = new FileInputStream(local)) {
                    zout.putNextEntry(getNewEntry("maven/" + artifact.getPath()));
                    copy(fin, zout);
                }
                added++;
            }
        } catch (IOException e) {
            e.printStackTrace();
            error("Failed to copy installer jar: " + e.getMessage());
            return false;
        }

        return true;
    }

    @Override
    protected List<Library> getLibraries() {
        List<Library> tmp = super.getLibraries();
        tmp.addAll(Arrays.asList(this.processorsServer.getLibraries()));

        // Prevent duplicates because why waste time
        List<Library> ret = new ArrayList<>();
        Set<String> seen = new HashSet<>();

        for (Library lib : tmp) {
            if (seen.add(lib.getName().getPath()))
                ret.add(lib);
        }

        return ret;
    }

    @Override
    public boolean isPathValid(File target) {
        target = cleanTarget(target);
        return !target.exists() || target.isFile();
    }

    @Override
    public String getFileError(File target) {
        target = cleanTarget(target);
        return "Target is not a file: " + target.getAbsolutePath();
    }

    @Override
    public String getSuccessMessage() {
        return String.format("Successfully created offline installer, downloaded %d libraries", added);
    }

    public static File findInstallerBase() {
        try {
            URI uri = Util.class.getResource("/install_profile.json").toURI();
            if (!"jar".equals(uri.getScheme()))
                throw new IllegalStateException("Could not find installer jar, if you're in a development environment, stick a pre-built installer jar in the gradle root directory and re-import your project");

            int lastExcl = uri.getRawSchemeSpecificPart().lastIndexOf("!/");
            String path = uri.getRawSchemeSpecificPart().substring(0, lastExcl);
            return Paths.get(new URI(path)).toFile();
        } catch (URISyntaxException e) {
            throw new RuntimeException("Unable to locate installer jar!", e);
        }
    }

    private File cleanTarget(File target) {
        if (target.isFile())
            return target;

        return new File(target, base.getName().substring(0, base.getName().length() - 4) + "-offline.jar");
    }

    private ZipEntry getNewEntry(String name) {
        ZipEntry ret = new ZipEntry(name);
        //ret.setTime(628041600000L);
        return ret;
    }

    private static void copy(InputStream source, OutputStream target) throws IOException {
        byte[] buf = new byte[256];
        int length;
        while ((length = source.read(buf)) != -1) {
            target.write(buf, 0, length);
        }
    }
}
